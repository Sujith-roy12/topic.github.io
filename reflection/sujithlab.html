<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenges and Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f9f9f9;
            color: #333;
            line-height: 1.6;
        }
        h1, h2 {
            text-align: center;
            color: #005bb5;
        }
        section {
            margin: 20px auto;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 1000px;
        }
        h2 {
            margin-top: 20px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            margin: 10px 0;
        }
        p {
            margin: 10px 0;
        }
    </style>
</head>
<body>

<h1>Challenges and Reflections</h1>

<section>
    <h2>1. Challenges in Learning/Understanding the Concepts</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong> Understanding big-O notation and analyzing recursive algorithms were initially confusing. Breaking down recursive steps and determining time complexity were challenging.</li>
        <li><strong>Binary Search Tree (BST):</strong> Building and traversing BSTs while maintaining their properties was initially difficult but improved with practice.</li>
        <li><strong>DFS and BFS:</strong> Managing recursive stacks in DFS and handling disconnected components or cycles in BFS were tricky.</li>
        <li><strong>Heap:</strong> Understanding heapify operations and array representations of heaps was challenging initially.</li>
        <li><strong>Sorting:</strong> Comparing and choosing the best sorting algorithm for specific situations was overwhelming.</li>
        <li><strong>Pattern Searching:</strong> Algorithms like KMP and Boyer-Moore were complex due to the need for table construction and pattern shifting calculations.</li>
        <li><strong>Graph Algorithms:</strong> Representing graphs and implementing algorithms like Dijkstra's and Prim's were conceptually easy but hard to code with heaps.</li>
    </ul>
</section>

<section>
    <h2>2. Challenges in Correlating with Real-World Applications</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong> Understanding theoretical complexity in real runtime scenarios was abstract without examples.</li>
        <li><strong>Binary Search Tree:</strong> Relating BSTs to database indexing and handling unbalanced trees was tricky.</li>
        <li><strong>DFS and BFS:</strong> Applying these algorithms to social networks and web crawling was challenging to visualize.</li>
        <li><strong>Heap:</strong> Using heaps in priority queues and modifying them for real-world constraints was unclear.</li>
        <li><strong>Sorting:</strong> Choosing the right sorting algorithm for real-world applications was confusing.</li>
        <li><strong>Pattern Searching:</strong> Applying these algorithms to text processing or large datasets felt abstract.</li>
        <li><strong>Graph Algorithms:</strong> Implementing algorithms on large graphs like social networks was daunting.</li>
    </ul>
</section>

<section>
    <h2>3. Determining the Most Efficient Approach/Design Techniques</h2>
    <ul>
        <li><strong>Time Complexity Analysis:</strong> Comparing expected input size and algorithm growth helps in selecting the best approach.</li>
        <li><strong>Binary Search Tree:</strong> Using self-balancing trees for balanced operations and hash tables for sorted/repetitive data.</li>
        <li><strong>DFS and BFS:</strong> Using DFS for exploring possibilities and BFS for shortest paths in unweighted graphs.</li>
        <li><strong>Heap:</strong> Applying heaps for priority-based problems like scheduling tasks.</li>
        <li><strong>Sorting:</strong> Choosing quick sort for speed, merge sort for stability, and simpler algorithms for small datasets.</li>
        <li><strong>Pattern Searching:</strong> Using KMP for repetitive patterns and brute force for shorter texts.</li>
        <li><strong>Graph Algorithms:</strong> Selecting algorithms like Dijkstra for shortest paths and Prim's for MSTs based on graph type.</li>
    </ul>
</section>

</body>
</html>

